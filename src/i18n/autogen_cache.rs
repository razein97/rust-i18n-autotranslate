use std::{
    collections::HashMap,
    fs::{File, OpenOptions},
    io::{BufWriter, Read, Write},
    path::Path,
};

use serde::{Deserialize, Serialize};

use crate::utils::get_source_file_path;

#[derive(Debug, Default, Serialize, Deserialize)]
pub struct Autogen {
    pub sha256: Option<String>,
    pub data: HashMap<String, HashMap<String, String>>,
}

pub fn load_autogen() -> Autogen {
    //Using just create was replacing the file always, hence the additional check
    let auto_translate_file = File::create_new("./.autogen.toml");

    match auto_translate_file {
        Ok(_) => Autogen::default(),
        Err(_) => {
            let existing_file = File::open("./.autogen.toml");
            if let Ok(mut file) = existing_file {
                let mut buffer = Vec::new();
                let string_bytes = file.read_to_end(&mut buffer);

                if let Ok(_) = string_bytes {
                    let parsed = toml::from_slice::<Autogen>(&buffer);
                    if let Ok(autogen) = parsed {
                        autogen
                    } else {
                        Autogen::default()
                    }
                } else {
                    Autogen::default()
                }
            } else {
                Autogen::default()
            }
        }
    }
}

pub fn update_autogen_cache(autogen: &Autogen) -> Result<(), &'static str> {
    let auto_translate_file = OpenOptions::new()
        .write(true)
        .truncate(true)
        .open("./.autogen.toml")
        .map_err(|_| "Could not open autogen")?;
    let mut writer = BufWriter::new(auto_translate_file);

    let comment =
        "# autogenerated by rust-i18n-autotranslate\n# can be checked into version control\n\n";

    let toml = toml::to_string(&autogen).map_err(|_| "Could not serialize data")?;

    let final_write = format!("{comment}{toml}");

    writer
        .write_all(final_write.as_bytes())
        .map_err(|_| "Could not write autogen data")
}

/// If it does not match then return the new sha256
pub fn is_match_sha256(locale_path: &Path, source_lang: &str, autogen_sha: &str) -> Option<String> {
    let res = get_source_file_path(locale_path, source_lang);
    if let Some(item_path) = res {
        let sha256_res = sha256::try_digest(item_path);
        if let Ok(sha) = sha256_res {
            if autogen_sha != sha { Some(sha) } else { None }
        } else {
            None
        }
    } else {
        None
    }
}
